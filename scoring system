import cv2
import numpy as np

def draw_pockets(image):
    pocket_coordinates = [
        (40, 80), (960, 80), (1880, 80),  # Top row
        (40, 1010), (960, 1010), (1880, 1010)  # Bottom row
    ]

    for pocket_coord in pocket_coordinates:
        cv2.rectangle(image, (pocket_coord[0] - 40, pocket_coord[1] - 40), (pocket_coord[0] + 40, pocket_coord[1] + 40), (255, 0, 0), 4)

def draw_circles(contours, image, min_diameter=23, max_diameter=30):
    result_image = image.copy()
    
    for contour in contours:
        M = cv2.moments(contour)
        if M['m00'] == 0:
            continue

        cX = int(M['m10'] / M['m00'])
        cY = int(M['m01'] / M['m00'])

        radius = max(min_diameter // 2, min(max_diameter // 2, int(np.sqrt(cv2.contourArea(contour) / np.pi))))

        cv2.circle(result_image, (cX, cY), radius, (0, 255, 0), 2)

    return result_image
    
def filter_ctrs(ctrs, alpha=1.0, min_s=100, max_s=5000):
    filtered_ctrs = []

    for x in range(len(ctrs)):
        rot_rect = cv2.minAreaRect(ctrs[x])
        w = rot_rect[1][0]
        h = rot_rect[1][1]
        area = cv2.contourArea(ctrs[x])

        if (h * alpha < w) or (w * alpha < h):
            continue

        if (area < min_s) or (area > max_s):
            continue

        filtered_ctrs.append(ctrs[x])

    return filtered_ctrs

def find_ctrs_color(ctrs, input_img):
    K = np.ones((3, 3), np.uint8)
    output = input_img.copy()
    gray = cv2.cvtColor(input_img, cv2.COLOR_BGR2GRAY)
    mask = np.zeros(gray.shape, np.uint8)

    for i in range(len(ctrs)):
        M = cv2.moments(ctrs[i])
        cX = int(M['m10'] / M['m00'])
        cY = int(M['m01'] / M['m00'])

        mask[...] = 0
        cv2.drawContours(mask, ctrs, i, 255, -1)
        mask = cv2.erode(mask, K, iterations=3)

        output = cv2.circle(output, (cX, cY), 20, cv2.mean(input_img, mask), -1)

    return output

def process_frame(frame):
    transformed_blur = cv2.GaussianBlur(frame, (5, 5), 2)
    blur_RGB = cv2.cvtColor(transformed_blur, cv2.COLOR_BGR2RGB)

    lower = np.array([50, 120, 30])
    upper = np.array([70, 255, 255])

    hsv = cv2.cvtColor(blur_RGB, cv2.COLOR_RGB2HSV)
    mask = cv2.inRange(hsv, lower, upper)

    kernel = np.ones((5, 5), np.uint8)
    mask_closing = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)

    _, mask_inv = cv2.threshold(mask_closing, 5, 255, cv2.THRESH_BINARY_INV)

    masked_img = cv2.bitwise_and(frame, frame, mask=mask_inv)

    # Shadow filtering
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    _, thresh_gray = cv2.threshold(gray, 150, 255, cv2.THRESH_BINARY)

    mask_inv_no_shadow = cv2.bitwise_and(mask_inv, thresh_gray)

    # Improved edge detection using Canny (50,150)
    edges = cv2.Canny(mask_inv_no_shadow, 50, 150)

    # Dilation to connect edges
    dilated_edges = cv2.dilate(edges, None, iterations=2)

    # Find contours in the dilated edges
    ctrs, hierarchy = cv2.findContours(dilated_edges, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    detected_objects = draw_circles(ctrs, frame, min_diameter=25, max_diameter=30)
    #23,35

    ctrs_filtered = filter_ctrs(ctrs)
    detected_objects_filtered = draw_circles(ctrs_filtered, frame, min_diameter=23, max_diameter=30)

    ctrs_color = find_ctrs_color(ctrs_filtered, frame)
    ctrs_color = cv2.addWeighted(ctrs_color, 0.5, frame, 0.5, 0)

    return detected_objects

# Read video file
video_path = "snooker_video.mp4"
cap = cv2.VideoCapture(video_path)

cv2.namedWindow('output', cv2.WINDOW_NORMAL)
cv2.moveWindow('output', 0, 0)

font = cv2.FONT_HERSHEY_SIMPLEX
player1_score = 0
player2_score = 0
red_balls_on_table = 15
colored_balls_on_table = 6
reds_potted = 0
colored_potted = 0
player_score = 0
players = ["Player 1", "Player 2"]
current_player_index = 0
player_attempts_hit_cue_ball = False
ball_potted_is_red = False
ball_potted_is_colored = False
colored_ball_is_yellow = False
colored_ball_is_green = False
colored_ball_is_brown = False
colored_ball_is_blue = False
colored_ball_is_pink= False
colored_ball_is_black = False

while cap.isOpened():
    ret, frame = cap.read()

    if not ret:
        break

    # Process the frame
    result = process_frame(frame)

    # Draw pockets on the frame
    draw_pockets(result)

    # Check if red and colored balls are on the table
    if red_balls_on_table + colored_balls_on_table > 0:
        # Replace these conditions with your actual video processing logic
        player_attempts_hit_cue_ball = True  # Placeholder, replace with actual logic
        ball_potted_is_red = True  # Placeholder, replace with actual logic
        ball_potted_is_colored = True  # Placeholder, replace with actual logic
        colored_ball_is_yellow = True  # Placeholder, replace with actual logic
        colored_ball_is_green = True  # Placeholder, replace with actual logic

        if player_attempts_hit_cue_ball:
            if ball_potted_is_red:
                reds_potted += 1
                red_balls_on_table -= 1
                player_score += 1

                if colored_potted < 1:
                    current_player_index = (current_player_index + 1) % 2
                    colored_potted = 0

            elif ball_potted_is_colored:
                colored_potted += 1
                colored_balls_on_table -= 1

                if colored_ball_is_yellow:
                    player_score += 2
                elif colored_ball_is_green:
                    player_score += 3
                # Add similar conditions for other colored balls

                current_player_index = (current_player_index + 1) % 2
                reds_potted = 0

            else:  # No balls potted
                current_player_index = (current_player_index + 1) % 2
                reds_potted = 0
                colored_potted = 0

        # Display current player and their score
        player_text = f'{players[current_player_index]}: {player_score}'
        cv2.putText(result, player_text, (50, 50), font, 1, (255, 255, 255), 2, cv2.LINE_AA)

        # Resize the video frame to a common width (1600 pixels) for combining
        output_frame_resized = cv2.resize(result, (1600, 1080))

        # Create a combined frame for video and scoreboard
        combined_frame = np.zeros((1080, 1920, 3), dtype=np.uint8)
        combined_frame[:, :1600] = output_frame_resized  # Display video frame
        combined_frame[:, 1600:] = (255, 255, 255)  # White background for scoreboard
        cv2.putText(combined_frame, f'Player 1: {player1_score}', (1650, 100), font, 1, (0, 0, 0), 2, cv2.LINE_AA)
        cv2.putText(combined_frame, f'Player 2: {player2_score}', (1650, 200), font, 1, (0, 0, 0), 2, cv2.LINE_AA)

        cv2.imshow('output', combined_frame)

        if cv2.waitKey(1) & 0xFF == ord('q'):  # Press 'q'
            break

cap.release()
cv2.destroyAllWindows()